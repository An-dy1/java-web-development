Special Methods
================

Every class has a few special methods that belong to it, regardless of
whether or not we define them. Exactly *how* every class obtains these
methods will be explored in a future lesson. For now, let’s look at the
most important of these methods.

``toString``
-------------

The ``toString`` method returns a string representation of a class.
Calling ``toString`` on a class that you’ve written will result in
something like this:

.. sourcecode:: bash

   org.launchcode.java.demos.java4python.school.Student@61bbe9ba

Here, we called ``toString`` on a ``Student`` object. Generally, the
default ``toString`` implementation is not very useful, and you’ll want
to override it. You can write your own ``toString``. Here’s how we might
do it for ``Student``:

.. code:: java

   public String toString() {
       return name + " (Credits: " + numberOfCredits + ", GPA: " + gpa + ")";
   }

This would result in a much more friendly message:

.. sourcecode:: bash

   John (Credits: 0, GPA: 0.0)

Note that ``toString`` is often implicitly called for you. For example,
the output above could have been generated by the following code, which
calls ``toString`` on ``john`` within ``System.out.println``.

.. code:: java

   Student john = new Student("John");
   System.out.println(john);

``equals``
-----------

Suppose we had two objects of type ``Student``, say ``student1`` and
``student2``, and we wanted to determine if they were equal. We might
try to compare them using ``==``, but since these are
`references <../data-types#references>`__ - that is, the variables hold
a reference to, or the *address* of, the actual ``Student`` objects -
they will evaluate as equal only when they have the same address. In
other words, they will be equal only when they refer to, or point at,
the exact same object. This is not usually what we want to check for.
For example, we might want to consider two student objects equal if they
have the same name, email, or student ID.

The ``equals()`` method can be used to determine if one object is equal
to another in this sense. We introduced this method when discussing
strings, but it also applies to all other classes. Below is code showing
how you might use it to compare two students. Note that they have
different names, but the same student ID, indicating they are actually
referring to the same person.

.. code:: java

   Student bono1 = new Student("Paul David Hewson", 4);
   Student bono2 = new Student("Bono", 4);

   if (bono1.equals(bono2)) {
       System.out.println(bono1.getName() +
           " is the same as " + bono2.getName());
   }

If we don’t provide our own ``equals()`` method, then the one provided
for us will only consider two objects equal if they are the *exact same
object*. In other words, they will only be considered equal if the
variables referring to the given objects both point to the same object.
This is the same behavior that we would see when using the ``==``
operator: ``bono1 == bono2``. This expression will evaluate to true only
if the variables actually refer to the same object. So in the example
above, since we have created two different ``Student`` objects, the
expression will evaluate to false.

This kind of comparison is often not what we want. The difference
between the comparison carried out by the default ``equals()`` method
(and by the ``==`` operator), and how we would like our classes to
behave, is the difference between *identity* and *equality*. Two things
can be considered *equal* even if they are not the exact same item -
that is, if they are not identical. So the default ``equals()`` method
and the ``==`` operator test for identity, whereas we want to test for
equality instead. We can do so by **overriding** the ``equals()``
method. We will discuss overriding in more detail later, but for now
just know that it entails creating different behavior for an existing
method.

For example, in the case of the ``Student`` class, we might specify that
two ``Student`` objects are equal if they have the same ID. We would
then write a new method definition for ``equals()`` as follows:

.. code:: java

   public boolean equals(Object o) {
       Student theStudent = (Student) o;
       return theStudent.getStudentId() == getStudentId();
   }

Now if we evaluate ``bono1.equals(bono2)`` we will get a result of true,
since the student IDs match.

One catch of working with ``equals()`` is that its input parameter must
be of type ``Object``, even if we’re working in a class like
``Student``. The reason why will become more clear in the next lesson,
when we introduce the ``Object`` class. For now, the practical
implication is that we must convert, or **cast**, the input ``o`` to be
of type ``Student`` with the syntax ``(Student) o``. Then we compare the
converted student’s ID to that of the current student.

Here’s a visualization of the concepts of equality and identity:

**Equality**

.. figure:: ./figures/equality.png
   :alt: Equality

   Equality

When you are testing for equality, you will be looking at two different
objects and comparing some aspect of them to each other.

**Identity**

.. figure:: ./figures/identity.png
   :alt: Identity

   Identity

When you are testing for identity, you will look at two variables to see
if they reference the exact same object.

You’ll often want to implement ``equals()`` yourself. However, if you do
so, be sure to understand best practices around how the method should
behave, which are `not so
simple <https://www.sitepoint.com/implement-javas-equals-method-correctly/>`__.
In fact, the ``equals()`` method we have here isn’t very good by most
Java programmers’ standards. Let’s improve on it.

**Problem #1**: The method argument can not be converted to a
``Student`` instance.

When we attempt to cast the argument ``o`` to type ``Student``, we’ll
get an exception if ``o`` can’t be properly converted. This would happen
if somebody passes something other than a ``Student`` object into
``equals()``. To prevent this from happening, we’ll return ``false`` if
``o`` was not created from the ``Student`` class, as determined by using
the ``getClass`` method, which is available to every object (similarly
to ``toString``).

.. code:: java

   public boolean equals(Object o) {

       if (o.getClass() != getClass()) {
           return false;
       }

       Student theStudent = (Student) o;
       return theStudent.getStudentId() == getStudentId();
   }

This check ensures that the two objects that we want to compare were
created from the same class.

**Problem #2:** ``o`` might be ``null``.

If ``o`` is ``null`` then ``o.getClass()`` will result in an exception.
This is an easy issue to fix, since comparing a non-null object to
``null`` will evaluate to ``false``. Therefore, if this comparison
evaluates to true then we know that the object is null and ``equals()``
should return false.

.. code:: java

   public boolean equals(Object o) {

       if (o == null) {
           return false;
       }

       if (o.getClass() != getClass()) {
           return false;
       }

       Student theStudent = (Student) o;
       return theStudent.getStudentId() == getStudentId();
   }

**Problem #3:** The two objects to compare are *the same* object.

This is less of a problem per se and more of a way we can improve our
``equals()`` method. If ``o`` is the same literal object that we are
attempting to compare it to, then we can make a quick determination and
save a few checks.

.. code:: java

   public boolean equals(Object o) {

       if (o == this) {
           return true;
       }

       if (o == null) {
           return false;
       }

       if (o.getClass() != getClass()) {
           return false;
       }

       Student theStudent = (Student) o;
       return theStudent.getStudentId() == getStudentId();
   }

Components of equals
^^^^^^^^^^^^^^^^^^^^

Almost every equals method that you write will look similar to this one,
and will contain the following segments, in order:

1. **Reference check:** If the two objects are the same, return ``true``
   right away.
2. **Null check:** If the argument is ``null``, return ``false``.
3. **Class check:** Compare the classes of the two objects to ensure a
   safe cast.
4. **Cast:** Convert the argument to the type of our class, so getters
   and other methods can be called.
5. **Custom comparison:** Use custom logic to determine whether or not
   the two objects should be considered equal. This will usually be a
   comparison of properties or fields.

Characteristics of equals
^^^^^^^^^^^^^^^^^^^^^^^^^

Now that we know how to write an ``equals()`` method, let’s look at some
characteristics that every such method should have. If you follow the
general outline above, ensuring that your ``equals()`` method has these
characteristics should be straightforward.

1. **Reflexivity:** For any non-null reference value ``x``,
   ``x.equals(x)`` should return ``true``.
2. **Symmetry:** For any non-null reference values ``x`` and ``y``,
   ``x.equals(y)`` should return ``true`` if and only if ``y.equals(x)``
   returns true.
3. **Transitivity:** For any non-null reference values ``x``, ``y``, and
   ``z``, if ``x.equals(y)`` returns ``true`` and ``y.equals(z)``
   returns ``true``, then ``x.equals(z)`` should return ``true``.
4. **Consistency:** As long as ``x`` and ``y`` do not change
   ``x.equals(y)`` should always return the same result.
5. **Non-null:** For any non-null reference value ``x``,
   ``x.equals(null)`` should return ``false``.

If you think about your innate sense of the concept of equality, say,
from a math class, then these concepts make sense. While using the
general approach outlined above for implementing ``equals()`` will
generally make these relatively simple to guarantee, not doing so can be
disastrous for your Java applications.

.. raw:: html

   <aside class="aside-pro-tip">

Seasoned Java developers will tell you that every time you implement
your own version of ``equals()`` you should also implement your own
version of ``hashCode()``. ``hashCode()`` is another special method that
every class has. Understanding ``hashCode()`` would take us a bit far
afield at this point, but we would be remiss to not mention it. If you
want to read more, `check out this
article <https://www.sitepoint.com/how-to-implement-javas-hashcode-correctly/>`__
and `this stack
overflow <https://stackoverflow.com/questions/2265503/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java>`__.

To ensure that you create a well-structured ``hashCode()`` method
whenever providing your own ``equals()`` method, you can use IntelliJ’s
code generation tool. To do so, right-click within your class file and
select *Generate > equals and hashCode* and follow the prompts.

.. raw:: html

   </aside>

While you may not need to write your own ``equals()`` method for each
class you create, the more immediate implication for you as a new Java
programmer is that you should *always use* ``equals()`` yourself when
comparing objects. This is especially true when working with objects of
types provided by Java, such as ``String``. A class that is part of Java
or a third-party library will have implemented ``equals()`` in a way
appropriate for the particular class, whereas ``==`` will only check to
see if two variables refer to the same literal object.

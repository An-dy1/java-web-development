Customizing Fields
===================

In the previous chapter, we used *fields* to store data within a class, and we
explored how to access and modify the values of those fields.

Now, we will explore several ways to configure fields based on their intended
use.

.. index:: ! final field

Final Fields
-------------

A **final field** is one that cannot be changed once it is initialized. This
means slightly different things for primitive and class types. We create final
fields by declaring them with the ``final`` keyword.

**Final primitive fields** cannot change their value once they are initialized.

**Final object fields** may not change the object that they hold once they are
initialized. However, that object itself my change.

Here are some examples to illustrate. Each class would normally be in its own
file, but we present them side-by-side for convenience. Additionally, we
declare each field ``public`` to minimize the example code and more clearly
demonstrate where compiler errors would occur.

.. sourcecode:: java
   :linenos:

   public class FortyTwo {

      public int intValue = 42;

   }

   public class FinalFields {

      public final int intValue = 42;
      public final double doubleValue;
      public final FortyTwo objectValue = new FortyTwo();

      public static void main(String[] args) {

         FinalFields demo = new FinalFields();

         // This would result in a compiler error
         demo.intValue = 6;

         // This is allowed since we haven't initialized doubleValue yet
         demo.doubleValue = 42.0;

         // However, this would result in a compiler error
         demo.doubleValue = 6.0;

         // This would result in a compiler error, since we're trying to
         // give objectValue a different object value
         demo.objectValue = new FortyTwo();

         // However, this is allowed since we're changing a field
         // inside the final object, and not changing which object
         // objectValue refers to
         demo.objectValue.intValue = 6;
      }
   }

Final fields can be confusing at first. If you’ve encountered references, or
pointers, in your programming journey, then final fields might make more sense
if you know that an object field actually holds a pointer to an object, and not
the object itself.

   TODO: Fix the phrasing in the previous paragraph.

Note that a final field *may not* have a setter.

.. index:: ! static field

Static Fields
--------------

A **static field** is one that *shared by all instances of the class*, and it
is declared with the ``static`` keyword.

For example, in our ``Temperature`` class there is no reason for each
``Temperature`` object to hold its own copy of the double
``absoluteZeroFahrenheit``. That value remains constant from class to class and
object to object. Because of this, we make it a ``static`` field.

Previous examples used the ``static`` keyword with both fields and methods, but
since this discussion is focused on data, let’s focus on static fields for now.

.. sourcecode:: java
   :linenos:

   public class Temperature {

      private double fahrenheit;

      private static double absoluteZeroFahrenheit = -459.67;

      public double getFahrenheit() {
         return fahrenheit;
      }

      public void setFahrenheit(double aFahrenheit) {

         if (aFahrenheit < absoluteZeroFahrenheit) {
            throw new IllegalArgumentException("Value is below absolute zero");
         }

         fahrenheit = aFahrenheit;
      }

      /* rest of the class... */

   }

There are multiple ways to refer to a static field.

.. sourcecode:: java

   // Within the class, use it the same as a normal, non-static field
   System.out.println("Absolute zero in F is: " + absoluteZeroFahrenheit);

   // Also within the class, we can be more explicit
   System.out.println("Absolute zero in F is: " + this.absoluteZeroFahrenheit);

.. sourcecode:: java

   // Outside the class, if the field is public, we can do this
   System.out.println("Absolute zero in F is: " + Temperature.absoluteZeroFahrenheit);

   // Or if we have an object named "temp" of type Temperature
   System.out.println("Absolute zero in F is: " + temp.absoluteZeroFahrenheit);

In the second code snippet, it is much more preferable to use the first
technique, to make it explicit that the field you’re using is static
(this isn’t clear in the bottom case).

   TODO: Fix the phrasing in the previous paragraph.

.. admonition:: Example

   As another example, we might also provide a third constructor for our
   ``Student`` class that only requires the student’s name. Theoretically, the
   ``studentId`` would (or could) be generated by the class itself.

   .. sourcecode:: java
      :linenos:

      public class Student {

         private static int nextStudentId = 1;
         private String name;
         private final int studentId;
         private int numberOfCredits;
         private double gpa;

         public Student(String name, int studentId,
                  int numberOfCredits, double gpa) {
            this.name = name;
            this.studentId = studentId;
            this.numberOfCredits = numberOfCredits;
            this.gpa = gpa;
         }

         public Student(String name, int studentId) {
            this(name, studentId, 0, 0);
         }

         public Student(String name) {
            this(name, nextStudentId);
            nextStudentId++;
         }

         /* getters and setters omitted */

      }

In line 3, we add a static integer field that will keep track of the next
student ID to be assigned to a student. Then, our new constructor (line 21)
takes only a name as a parameter and assigns the student the next available ID.
This works because static fields are shared across all objects created from
the ``Student`` class, so it functions as a counter of sorts for the number of
``Student`` objects created.

Constants
----------

Unlike some other languages, Java doesn’t have a special keyword to declare a
constant, or unchanging, variable. However, we can achieve the same result
using a combination of ``static`` and ``final``.

.. sourcecode:: java
   :linenos:

   public class Constants {
      public static final double PI = 3.14159;
      public static final String FIRST_PRESIDENT = "George Washington";
   }

Throughout the rest of this course, when we say *constant* we will mean a
``static final`` variable.

Three things to note from this example:

#. We use a different naming convention for constants than for other variables.
   Constants should be in ALL CAPS, with an underscore to separate words.
#. There is no strong reason to make constants ``private``, since restricting
   access would force us to re-declare the same values in different classes.
   We’ll generally make our constants ``public``.
#. Declare and initialize constants at the same time. Otherwise, you run the
   risk of somebody else assigning them a value first!

A good use of a constant can be seen in our ``Temperature`` class. Since
absolute zero will never change, we can ensure that nobody ever alters it
(intentionally or by mistake) by adding ``final`` to make it a constant.

.. sourcecode:: java
   :linenos:

   public class Temperature {

      private double fahrenheit;

      public static final double ABSOLUTE_ZERO_FAHRENHEIT = -459.67;

      /* rest of the class... */

   }

References
----------

-  `Encapsulation
   (wikipedia.org) <https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)>`__
-  `Declaring Member Variables
   (docs.oracle.com) <https://docs.oracle.com/javase/tutorial/java/javaOO/variables.html>`__
-  `Initializing Fields
   (docs.oracle.com) <http://docs.oracle.com/javase/tutorial/java/javaOO/initial.html>`__
-  `Constructors
   (docs.oracle.com) <https://docs.oracle.com/javase/tutorial/java/javaOO/constructors.html>`__
